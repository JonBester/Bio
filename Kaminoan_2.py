#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Dec 15 08:04:36 2017

@author: jonathanbester
"""




#   -   Kaminoan In Vivo Cloning Designer   -


##INTRODUCTION
    # This is a program used for in vivo cloning (aka IV Assembly), which is a 
    # restriction digest and ligation independent cloning procedure. This process
    # works by inserting multiple partially overlapping DNA fragments into E. coli,
    # which subsequently undergo RecA-independent homologous recombination to 
    # produce intact plasmids. The conveniences of a procedure that is less laborious
    # than traditional restriction cloning, and that avoids the sequence limitations 
    # inherent in a procedure reliant on restriction enzymes are obvious. However
    # IVA cloning is yet to observe widespread adoption due to the difficulty of 
    # designing multiple PCR guides for each fragment that will produce the required 
    # sequences, whilst possessing sufficiently similar melting points to enable 
    # parallel PCR. This program takes the parameters provided in the references 
    # below to produce PCR guides that will 1. produce sufficient overlap regions 
    # to enable facile IVA once transformed into cells, 2. have an initial melting 
    # temperature of ~50 and a subsequent Tm of ~ 58-63 - enabling simultaneous 
    # amplification of all desired fragments from their respective backbones. This
    # procedure makes for an alternative to traditional cloning or even full plasmid 
    # assembly procedures such as golden gate. 
    
##References:
    # Initially I came across this procedure in internal SOPs from the University 
    # of Queensland's Protein Expression Facility. I drew on the following references
    # to design the parameters of Kaminoan. To use this procedure you must: 
    # 1. produce the PCR products using the primers generated by this program, 
    # eliminating any residual plasmid by either gel purification, DpnI treatment 
    # or the "double tap" PCR procedure as suggested in Huang et al (2017) below. 
    # 2. transform all pcr fragments into competent E. coli.
    
    #1
        # Huang, F., Spangler, J. R., & Huang, A. Y. (2017). 
        # In vivo cloning of up to 16 kb plasmids in E. coli is as simple as PCR. 
        # PloS one, 12(8), e0183974.
    
    #2
        # García-Nafría, J., Watson, J.F. and Greger, I.H., 2016. 
        # IVA cloning: A single-tube universal cloning system exploiting 
        # bacterial In Vivo Assembly. Scientific Reports, 6.

##USAGE
    #1
    # Copy paste the DNA sequences you wish to clone below, each fragment will 
    # be attached to the one below it and above it at the right and left respectively. 
    # (the maximum number of fragments successfully demonstrated in literature 
    # is five as described in Huang et al (2017), this procedure will accept 1-8 
    # inputs if you are feel like living dangerously).
    
    #2 
    # If you want you can alter some of the program parameters. This program will
    # save a plasmid map to your current directory in genbank format (unless you 
    # change Format = "genbank" to "fasta"), the name of that plasmid is currently
    # "pKam_1" unless you change it (Name). The In_temp is the temperature of the first
    # round of PCR reaction, In_length is the length of the portion of the primer 
    # that binds in the first round of PCR (ie without the tail that generates an 
    # overlap). If you reduce both of these parameters the program will output 
    # smaller, cheaper guides, however the overall reaction will proceed less efficiently.
    # either way the most crucial parameter - that inter-fragment overlap have a 
    # melting point ~47oC (in Garcia-Nafria), will be upheld.
    
    # The program will generate an output table listing a fragment ID, length of 
    # the fragment, where it will be inserted, a forward primer sequence, forward
    # primer length, forward primer initial temperature (for the first two rounds
    # of PCR), forward primer final temperature (for all subsequent rounds), and 
    # the same for a corresponding reverse primer. The previously mentioned genbank/
    # fasta file will also be generated. 
    

#insert desired cloning sequences below between the quotation marks.
frag1 = "TTGGGGCACCCAAGGCCTAGAGGGGAGCGTTAAGTCGGTTGTTTCAAGCTGGCCGCAGTCCCTGTTTGTTAGGCTCCGAGTTCGGCTATTCCCGGGTACACGGATGCCCTCGGCGGCTGTCAGTGGCTCACTGCGTACCCTCGCCCTAAAAATTTGCACGTACCCCAGATCTGTAAAGGACAAAACTTTGCGTACCTTCCAAGGAGCACGCTCCCCTGACGGCGAGGGCCGCTGTAGGAAAAGAGTTGCACCACCACCCTGTTTGTCGGTTTAAGGGTCACACTATTCGGGAACACTCTGCGTAATTCAGCGTGTCAGAACGAGCCTCCCTGACGCGATACTAGAGTACCTCGTTTCATGGATGTTATGACCTCAGAAATCGCATCCGACTTTGTCGCATCCTAAGAATGCCCCTTATCTGTCAGCAGTGGCGGCCAGCAAGGAAAATATAACATAGCGGGCCGGCACGCACTCATAATGAGTTACATTCATTGACATTTCGATCTTATGGCCAGTCGTCATGTTTCGACAAGCAGCATCGGTCGGCATTAAGGCTGCACGCACGGTTCGTCTCGTCGGCGCATCAAGGGCCTTCATTCTATGACGCTCCCCTAATTTCGCTTGTCGTATGACCCCCAGGGGGGCCATAATGGTTGGAGACTAATCAGACTCAACTGTTGAAGCGAGTATGAAAGTGGCCAGCCGCTTATCGGTGAGTTGCGTGCCAAGAGGTTCGACACGCCCGCGTATAACTTGCTCTCGGCATAAGAGGTGTGAACGGCAGATTGTTATTCTCGCATCACAGGAACCAGAGAATGTCGGTGACATTGAGGTGACGCACTGGGTTAAGATGTGATTCGGATAATAATGTTATTTTAGCAGATCAGCGTTTGGCCATGTGAAAGACTCGAGAAACTACTAGAACTTCATCCGGACAGAATATAACTGCCATAGCTGACGTAGTGCGCACTTCATAGGACGATTCGTTCAACGTGAGACTGGCTGCCTGGAGTTGAGCGAGCCTGTTCGCCTGCATCACACCTGGTTACGGAGACGGGTCTAAATTACGTTGCTCACTCCGTCCTAAATAGACTTAGAGCCGAGTCTTATTTTTGGCGGCCTCATCAATCCAACGGAACATGCATGATACTCTCCGTGAAGGGTAAATTCAGCTTCCGAAACCAGGTAAAAGTAGAGGTACTGCTAGGTGTCAAATACAAAAGTGTGCTCGCCCTGGGAAGGAGGCCCGCTTATGGCCCGGACCACCGAAAGTACCATTGCGTTGGCCATGTTACTGACTTTGGAGCTGAACCATCCTATACCGCACGCCACTAACTGCCCGAAAGTATGCCACGTTCTGACTCGAACACATTCTCTGCGAAGTCATCCGGCCTCTCTACTTTGTAGTATGACGCGCCACAGTCAGCCCAATGACTAGCCAATTATCTCGCAACCTCAGAGTAACCGCTTAGAAGATTAACCGGAGATGCAAGGGCTGCGTGGACTAAACTCCCGGGACGAAACGGCCCGATCGAAGGAGGACTGCTGGGCCGTAAATAGTGTTAATTGTTTCAGGGACGAAGTCCATCGTATCTCGGCGAGCAGCGTAACCATTCCTAGCTTGTTGCCGAGTCCAGCGACGCCCGCGTTATGCTGACGGCCGATACCATGTTGCGGACTCATACTACGTTTCCTTTGTAGCCATAACTGCCACGGGTTCTTAACCTGTGGGTTTTCAACTAGACAAACCGCAACATTATCATACTTGCCGTCAGTTAGCAAGGACCTCGTTCCACCACTCGATGTGCAGCGACACGGCAAGGGACAGTTGGTATTCTACGCGTGGCTTGTAACTGCTTTCCGACGGGACTCCAAGTGCTATAAATAATGAGACTACCATCTCAGCGTATACGGTTTAGCGGAGTGACCTATCCTCGCATAACAACTCGTGAGCGGTATGTCTTGTGGCTTAGTACAGCTCATCTTTGAGGGCCATTCTGGTTGATCACACCAAGCGCTATAGTCTTCAGCGATCCGTTGGCAAGATTACAGTTATAACGGACCCTAGTTAAAGTTCGGAGCTGCGTCTTGAGTGGACGTCGCGGGAAGATACACGCCAACCGCCAGAAGAACCAAGGGACACTCAATTGATCTCAGTCAATTAGATGGTTACGCAGCTACACGGGGGCCTGTTCCACCTCGCGCGCCGTTGCGTATTACCTGGTGTATTCTTGCATGGAAGAGCGGTTTCCCCTGTAGGGCCTTCAGTTCCTACTAGACACATTTTTAGCTGCCTACGTTGACATCTGAGGTAACCAGCGATAAAATGAACCATCGTGAAGGACTGAATATGGGCAGCGGCTATGTTACGATAGGCGCTTACGTCGTGCATAAAATTAGCTGGAGGTTGGGGTTTCGCAGTGACACTCCCGCCGATGCGAGTTTCCTGATCCTAGAGGGCAATTTATCATTGTAAGCCGGGAACATTAGTGTCGCAATAGCATCTGCCTTGGGGCACTGTTTCAGCGGCATGCTCCTCACGTTTCGTCAGCGACAGTGTAGGCATCAATGACAGGCGTCGCCGTCGTGTCCACTAGGCGAGGCACGCTGTAAAAGCCCGGGAGTTTAGAATAGCCCTCTGCGGACCCAACGGCAGGTATCGAATCCCCCCCCAAAACATAATACATCAGACATGCGAGTGAAGGCCGGGCTTGACCTGGTAGAACGGCCCTTGAGGCTTGCGGTGCTGTTAGGACCCTAAATTAGTTATGATTCGCTTCGAACGGCCAACAGGCTTTTTTTGTACTAGTCAATACGCTACTCGCGGTGCCTCCGAGGGGCGACCCAAATTCCCAGTGCTTGTCCGACAACTGAAGCCGAAGCAAACAGCTCACCATCCCCGCTGGAGGAACGAGATGGGGACCAGCTAGAAACCTTGGTGAGCGAATCCAGCGGGTTTTGGTTACTAGCAAGTATTTGCGTTTGGTGTTTATTCGTAGAAGTTGGTGGACAGCTGGCTGAGTACGGTCTTATGTACGTAGCCCGGCATCTACACCTGTCCGACTTGCGTACGACCCATGAAATCTACAAGCATTTGGAAGTCGAGTCAGCGTATCAGGGTACTTTTGGTATATGGATTGATGAAATTGCAGGATCGAAAGCCGTTTATGCGATTTGCGGGTGGCTGCCCCTAAGCGCAGTCTTAGTAAAGATATACCGGACGCTTAGTTCCCGCGCTGCGGGACCGTCGCCATATAAGATGTCCATACAGTCTACAATCCTGGAGAAACCGAAAGCCGGTTGTCGCACTGTCGTGTGTCCGTTCCTTGAAACTAAGCACTAGACTTTAGTGACTTAGAAGACTGTACATTCCGCATGTGAGCCGTTCGGATGTCGCACAGTCCTATACTGACGCTTGATCAGCAAACCCCTCAGAAAAGCCCCTCTGAATGTCCGCCACCCGTGATGCAAAAGCCCCCCGCCATCGTGGTTGTGTATATCGAACATCTCGCGCAGCGAAGATCTAGGGTCAGTATAAGGCGCGGTGAGTGGATATTGAATCCAGGAGTCTCAGCATTCCAAATATGACTCCGTGGCAAGTCGCATTGTTTCACTCAGCAATTAGAGAAACCGAAAGTGTCCCGAGACCTTATGGAATTCCTAGTTGTCATTTTGTTGGGATCCAGTTACCTCATTTGAACCTCGTGCCCGAGGACGGCAATGGTCCATCTATGGTGTCCGTACACGAATTGACTCAATGCACCAGGTAATCCAAAAAAAATATGCAAAATATGATATTGTACGGATTTAATATAGATCAGTGTCGCGGGTGTTGTAACGTTATGAGTATTTTGACAAGAATCCTCGTTATAACTTATAACTACGGATCTCATGTGGTTTTTCACTATACTGGCATGATCGATCCTGCCTTAACCAGGGCCGGCCGATGCGACCCCATAGCTCTGCGTTGGTCGATTAACTGAACGAAACCACAAGACTACAAGTTTAGGCCTCTGCAGACGGAATACACTCCTGCCGGGCAAATCATCTAGGTCACGGGCCCACAAGATACAGAGATCCAGCTCCCTGTTTGCGGCTTTAACGCCGTGCGTGCCGGGGTCTTATTTATGAACGTAATTCCGTGCGCAAGTGTATGAGGAGCCAGAGTAAAAGGTGCGAACGGGTCAAATATTCCTTACCTATACACGTGGTTACGGGGCCATGTGACCCAGTCCCATATGCAGCGAGGCCCACGCGCAAGGTCAGGAGGTAAAGTTGCAAATTTATTTACAAGGGGGAGTCGGAGGCGGTAGAAGAAAGCTGAGCAATTCATAGAGTAGTTTCCCGTATAAAGACCAGCAGCGCGTTTAATTCTATGTTGAGGGTCCTGCCGTGGCAATACAGGTCACGTATGATCTGCGTTCCATTGATGCTCCGTATGCCTAGGAGGTCAGGTGCTCAGTACTGGCTCACTTAGTATGCCACTTTGCCGCGTAAGCCTTAAGTCAACCTTTGCGCACCACACAAGTTTATCGTGCATCGAGAACTACTCTTAAGTTCCGGGGGCTGCGCCCAGGGCATCTGTGCCGGTGGTACAGCTAACCATTTCGCAGGGCGGGAGTTTTAAAATGTTATATTGTCAGAATCTATCACGGTCCGCCTGCTAATTTTCCATACGACCCCGCGCATTGGACTCAAGTCATTTAGAGCGTACGAAAAGCTCCATTGATGAGGACCCATCTGGCGATTAATGGGAAAAACCTTACCAATATAGGAGCTTTACAGAGACTAAGACGTCGATCACCCTACAAACCTCGTCGACACCCCGACTCACTACGTAGGAACTAGGGTGTCTTAAATAACACAACGCCACAGGCACGACAAACTGGTTTGACATCTTCTCGGTGCCTGGAGATTGTTCTCAAACACTACACGTTGAAATCCGGGGACAAAGTAACCAATGTGCCGCATATTCCAAAAGAACCAGGGGCACAAGGTGC"
frag2 = "insert fragment sequence here."
frag3 = "ACGAAGAAGAACTAAGTACGTCGATCACGGACCCTGAGACAATCTGCCGACATCGTTTTCTTTCCAATGGCATTCACTAATATCAAAAGTGAGGCTCCAGTGCCCTAGAGATACACAAACGATGGCAGGTCTAAGAGGCCTTCCCAAGTAGGTGCGCCATTGACATCAAATCCGAGTACACTAGCTTTTGTCCAACGGCCTATGAATTAACTAGCGGTTAATTTCCTTGTTAGAGGCTAGATTAGGTAAAGCCGGAACGTTGGAACCTAGCTAAACATTCTTGGAACCTATCATCGTCTGAATGAGCGCAAACCGGACAGCCGCACTCTTAACTACGTTTTGCGAGGAGTATGCGACACCACGGCGACCTAAGGACCCGGACTCTTTTCAGGTGCATTGCTAGGCCCCATAAAGGTATCTCTTCGGTAAGTCACCCTCTTCACGAGGTCCCCTATAACTCTGCAAAACCTGAAAGTGAACAAAATGAAGGGCGCGTAGGA"
frag4 = "ATAGGGATAATAGGGAAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGAAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGAAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGAAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATA"
frag5 = "GTTGGCCCGTTCATCCACAGGAACCAGCCATTTACCAAAGCCCATAGGGATAATAGGGAAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGAAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGAAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGAAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATAATAGGGATA"
frag6 = "Five is the maximum recommended number of fragments, but go ahead if you want"
frag7 = "Seriously, this is getting reckless"
frag8 = "DEFCON 1"

#Redefine any other parameters as required:
Format = "genbank"
Name = "pKam_1"
In_temp = 50
In_length = 10


###############################################################################

import pandas as pd
import datetime
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO
from Bio.Alphabet import IUPAC
from Bio import SeqFeature as sf
from Bio.SeqUtils import MeltingTemp as mt

now = datetime.datetime.now()
date = str(now.month) + "_" + str(now.day) + "_" + str(now.year)
frag_list = []
frag_list.append(frag1)
frag_list.append(frag2)
frag_list.append(frag3)
frag_list.append(frag4)
frag_list.append(frag5)
frag_list.append(frag6)
frag_list.append(frag7)
frag_list.append(frag8)



def Kaminoan(frag_list, Dtemp = In_temp, OL = In_length, ty = Format, n = Name):
    """Takes a list of strings ATGC, an overlap length (integer between 9-25bp), and a name to call the outputted product. Then calculates appropriate primers and returns them in a panda table, as well as a fasta file of the final plasmid"""
    output = pd.DataFrame(columns = ["Seq_Length", "Fragments", "FW_Primer", "FW_length", "FW_inital_temp", "FW_final_temp", "RV_Primer", "RV_length", "RV_inital_temp", "RV_final_temp"])
    noncon = []
    delete = []
    for k in frag_list:
        for i in range(len(k)):
            if k[i] != "A" and k[i] != "C" and k[i] != "T" and k[i] != "G":
                delete.append(k)
    frag_list = [x for x in frag_list if x not in delete]
    for i in range(len(frag_list)):
        if len(frag_list[i]) < 60:
            print("fragment ", i, " is ", len(frag_list[i]), " bp, attempting PCR of fragments smaller than 60bp is not recommended")
        if len(frag_list[i]) < 100:
            print("fragment ", i, " is ", len(frag_list[i]), " bp long, consider just annealing oligos rather than PCR for short fragments such as these")
        for j in range(len(frag_list[i])):
            if frag_list[i][j] != "A" and frag_list[i][j] != "C" and frag_list[i][j] != "T" and frag_list[i][j] != "G":
                noncon.append((i, j, frag_list[i][j]))
    for i in range(len(frag_list)):    
        for j in range(len(frag_list[i])):
            if frag_list[i][j] != "A" and frag_list[i][j] != "C" and frag_list[i][j] != "T" and frag_list[i][j] != "G":
                print("Fragment ", i, " contains non-conventional (non-ACTG) characters and cannot be processed. Violating fragments, positions and characters are:", noncon)
                return
        #frag_list[i] = Seq(frag_list[i], IUPAC.unambiguous_dna)
    for i in range(len(frag_list)):
        if i == 0:
            #FW code starts here, remember to reuse L_RVnow at the end for the final RV_TOT
            L_FWnow = 7
            L_FWpast = 8
            C_FWnow = Seq(frag_list[i][0:L_FWnow])
            C_FWpast = Seq(frag_list[-1][len(frag_list[-1])-L_FWpast:len(frag_list[-1])])
            Overlap = C_FWpast + C_FWnow
            while mt.Tm_NN(Overlap) < 47:
                L_FWnow += 1
                C_FWnow = Seq(frag_list[i][0:L_FWnow])
                Overlap = C_FWpast + C_FWnow
                if mt.Tm_NN(Overlap) < 47:
                        L_FWpast += 1
                        C_FWpast = Seq(frag_list[-1][len(frag_list[-1])-L_FWpast:len(frag_list[-1])])
                        Overlap = C_FWpast + C_FWnow
            #now generate the forward primer
            j = OL
            FW_INI = Seq(frag_list[i][0:j])
            mtFW_INI = mt.Tm_NN(FW_INI)
            while mtFW_INI < Dtemp:
                j += 1
                FW_INI = Seq(frag_list[i][0:j])
                mtFW_INI = mt.Tm_NN(FW_INI)
            FW_TOT = C_FWpast.lower() + FW_INI
            mtFW_TOT = mt.Tm_NN(FW_TOT)
            ##RV code starts here with the overlap section
            L_RVnow = 7
            L_RVnext = 8
            C_RVnow = Seq(frag_list[i][len(frag_list[i])-L_RVnow:len(frag_list[i])])
            C_RVnext = Seq(frag_list[i+1][0:L_RVnext])
            Overlap = C_RVnow + C_RVnext
            while mt.Tm_NN(Overlap) < 47:
                L_RVnow += 1
                C_RVnow = Seq(frag_list[i][len(frag_list[i])-L_RVnow:len(frag_list[i])])
                Overlap = C_RVnow + C_RVnext
                if mt.Tm_NN(Overlap) < 47:
                        L_RVnext += 1
                        C_RVnext = Seq(frag_list[i+1][0:L_RVnext])
                        Overlap = C_RVnow + C_RVnext
            #now generate the reverse primer
            j = OL
            RV_INI = Seq(frag_list[i][len(frag_list[i])-j:len(frag_list[i])])
            mtRV_INI = mt.Tm_NN(RV_INI)
            while mtRV_INI < Dtemp:
                j += 1
                RV_INI = Seq(frag_list[i][len(frag_list[i])-j:len(frag_list[i])])
                mtRV_INI = mt.Tm_NN(RV_INI)
            RV_TOT = C_RVnext.reverse_complement().lower() + RV_INI.reverse_complement()
            mtRV_TOT = mt.Tm_NN(RV_TOT)
            #say where its going:
            fragments = "Inserts %0.0f between %0.0f and %0.0f" % (i, i-1, i+1)
            output.loc[i] = [len(frag_list[i]), fragments, str(FW_TOT), len(FW_TOT), mtFW_INI, mtFW_TOT, str(RV_TOT), len(RV_TOT), mtRV_INI, mtRV_TOT]
        if 0 < i < len(frag_list) -1:
            #generate the forward primer
            j = OL
            FW_INI = Seq(frag_list[i][0:j])
            mtFW_INI = mt.Tm_NN(FW_INI)
            while mtFW_INI < Dtemp:
                j += 1
                FW_INI = Seq(frag_list[i][0:j])
                mtFW_INI = mt.Tm_NN(FW_INI)
            FW_TOT = C_RVnow.lower() + FW_INI
            mtFW_TOT = mt.Tm_NN(FW_TOT)
            ##RV code starts here with the overlap section
            L_RVnow = 7
            L_RVnext = 8
            C_RVnow = Seq(frag_list[i][len(frag_list[i])-L_RVnow:len(frag_list[i])])
            C_RVnext = Seq(frag_list[i+1][0:L_RVnext])
            Overlap = C_RVnow + C_RVnext
            while mt.Tm_NN(Overlap) < 47:
                L_RVnow += 1
                C_RVnow = Seq(frag_list[i][len(frag_list[i])-L_RVnow:len(frag_list[i])])
                Overlap = C_RVnow + C_RVnext
                if mt.Tm_NN(Overlap) < 47:
                        L_RVnext += 1
                        C_RVnext = Seq(frag_list[i+1][0:L_RVnext])
                        Overlap = C_RVnow + C_RVnext
            #now generate the reverse primer
            j = OL
            RV_INI = Seq(frag_list[i][len(frag_list[i])-j:len(frag_list[i])])
            mtRV_INI = mt.Tm_NN(RV_INI)
            while mtRV_INI < Dtemp:
                j += 1
                RV_INI = Seq(frag_list[i][len(frag_list[i])-j:len(frag_list[i])])
                mtRV_INI = mt.Tm_NN(RV_INI)
            RV_TOT = C_RVnext.reverse_complement().lower() + RV_INI.reverse_complement()
            mtRV_TOT = mt.Tm_NN(RV_TOT)
            if i >= 1:
                fragments = "Inserts %0.0f between %0.0f and %0.0f" % (i, i-1, i+1)
            elif i == 0:
                fragments = "Inserts %0.0f between %0.0f and %0.0f" % (0, len(frag_list), 1)
            else:
                fragments = "FRAGMENT ID ERROR!!!"
            output.loc[i] = [len(frag_list[i]), fragments, str(FW_TOT), len(FW_TOT), mtFW_INI, mtFW_TOT, str(RV_TOT), len(RV_TOT), mtRV_INI, mtRV_TOT]
        if i == len(frag_list) - 1:
            #generate the forward primer
            j = OL
            FW_INI = Seq(frag_list[i][0:j])
            mtFW_INI = mt.Tm_NN(FW_INI)
            while mtFW_INI < Dtemp:
                j += 1
                FW_INI = Seq(frag_list[i][0:j])
                mtFW_INI = mt.Tm_NN(FW_INI)
            FW_TOT = C_RVnow.lower() + FW_INI
            mtFW_TOT = mt.Tm_NN(FW_TOT)
            #now generate the reverse primer
            j = OL
            RV_INI = Seq(frag_list[i][len(frag_list[i])-j:len(frag_list[i])])
            mtRV_INI = mt.Tm_NN(RV_INI)
            while mtRV_INI < Dtemp:
                j += 1
                RV_INI = Seq(frag_list[i][len(frag_list[i])-j:len(frag_list[i])])
                mtRV_INI = mt.Tm_NN(RV_INI)
            RV_TOT = C_FWpast.reverse_complement().lower() + RV_INI.reverse_complement()
            mtRV_TOT = mt.Tm_NN(RV_TOT)
            if i >= 1:
                fragments = "Inserts %0.0f between %0.0f and %0.0f" % (i, i-1, i+1)
            elif i == 0:
                fragments = "Inserts %0.0f between %0.0f and %0.0f" % (0, len(frag_list), 1)
            else:
                fragments = "FRAGMENT ID ERROR!!!"
            output.loc[i] = [len(frag_list[i]), fragments, str(FW_TOT), len(FW_TOT), mtFW_INI, mtFW_TOT, str(RV_TOT), len(RV_TOT), mtRV_INI, mtRV_TOT]
    total = ""
    for f in frag_list:
        total += f
    if len(total) > 15000:
        print("WARNING: total plasmid lengths of 15kb may result in cloning problems, consult Huang et al (2017)")
    totalsequence = SeqRecord(Seq(str(total), IUPAC.unambiguous_dna), id="pKam"+date, name=n, description="plasmid cloned in silico using Kaminoan in vivo cloner on the " + date)
    bp = 0
    for i in range(0,len(frag_list)):
        my_feature = sf.SeqFeature(sf.FeatureLocation(bp,bp+len(frag_list[i])),type="misc_feature")
        totalsequence.features.append(my_feature)
        bp += len(frag_list[i])
    #generate output map:
    if ty == "genbank":
        SeqIO.write(totalsequence, n, "genbank")   
    elif ty == "fasta":
        SeqIO.write(totalsequence, n, "fasta")
    else:
        print("variable ty must be specified as either genbank (default) or fasta in string format. " + ty + " is not an acceptable input for this variable")
    return output, totalsequence
    
print(Kaminoan(frag_list))


